<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · FinEtoolsDeforNonlinear.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FinEtoolsDeforNonlinear.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../guide/guide.html">Guide</a></li><li><span class="tocitem">Types and Functions</span><ul><li><a class="tocitem" href="types.html">Types</a></li><li class="is-active"><a class="tocitem" href="functions.html">Functions</a><ul class="internal"><li><a class="tocitem" href="#Helpers-1"><span>Helpers</span></a></li><li><a class="tocitem" href="#FEM-machines-1"><span>FEM machines</span></a></li><li><a class="tocitem" href="#Algorithms-1"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Material-models-1"><span>Material models</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Types and Functions</a></li><li class="is-active"><a href="functions.html">Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="functions.html">Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/master/docs/src/man/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h1><h2 id="Helpers-1"><a class="docs-heading-anchor" href="#Helpers-1">Helpers</a><a class="docs-heading-anchor-permalink" href="#Helpers-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{D}, Tuple{MV}, Tuple{T}, Tuple{FinEtoolsDeforNonlinear.AssemblyModule.SysvecAssemblerOpt{T},MV,D}} where D&lt;:(AbstractArray{Int64,N} where N) where MV&lt;:(AbstractArray{T,N} where N) where T&lt;:Number" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{D}, Tuple{MV}, Tuple{T}, Tuple{FinEtoolsDeforNonlinear.AssemblyModule.SysvecAssemblerOpt{T},MV,D}} where D&lt;:(AbstractArray{Int64,N} where N) where MV&lt;:(AbstractArray{T,N} where N) where T&lt;:Number"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(self::SysvecAssemblerOpt{T}, vec::MV,
  dofnums::D) where {T&lt;:Number, MV&lt;:AbstractArray{T}, D&lt;:AbstractArray{FInt}}</code></pre><p>Assemble an elementwise vector.</p><p>The method assembles a column element vector using the vector of degree of freedom numbers for the rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/AssemblyModule.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makevector!-Tuple{FinEtoolsDeforNonlinear.AssemblyModule.SysvecAssemblerOpt}" href="#FinEtools.AssemblyModule.makevector!-Tuple{FinEtoolsDeforNonlinear.AssemblyModule.SysvecAssemblerOpt}"><code>FinEtools.AssemblyModule.makevector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makevector!(self::SysvecAssemblerOpt)</code></pre><p>Make the global vector. Beware: the buffer itself is returned as the vector, <em>not</em> a copy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/AssemblyModule.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{FinEtoolsDeforNonlinear.AssemblyModule.SysvecAssemblerOpt{T},Int64}} where T&lt;:Number" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{FinEtoolsDeforNonlinear.AssemblyModule.SysvecAssemblerOpt{T},Int64}} where T&lt;:Number"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">startassembly!(self::SysvecAssemblerOpt{T},
  ndofs_row::FInt) where {T&lt;:Number}</code></pre><p>Start assembly.</p><p>The method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.</p><p><code>ndofs_row</code>= Total number of degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/AssemblyModule.jl#L33-L43">source</a></section></article><h2 id="FEM-machines-1"><a class="docs-heading-anchor" href="#FEM-machines-1">FEM machines</a><a class="docs-heading-anchor-permalink" href="#FEM-machines-1" title="Permalink"></a></h2><h3 id="Nonlinear-deformation-1"><a class="docs-heading-anchor" href="#Nonlinear-deformation-1">Nonlinear deformation</a><a class="docs-heading-anchor-permalink" href="#Nonlinear-deformation-1" title="Permalink"></a></h3><h4 id="Simple-FE-models-1"><a class="docs-heading-anchor" href="#Simple-FE-models-1">Simple FE models</a><a class="docs-heading-anchor-permalink" href="#Simple-FE-models-1" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.geostiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.AbstractFEMMDeforNonlinear,A,NodalField{Float64},NodalField{T},NodalField{T},Float64,Float64}} where T&lt;:Number where A&lt;:AbstractSysmatAssembler" href="#FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.geostiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.AbstractFEMMDeforNonlinear,A,NodalField{Float64},NodalField{T},NodalField{T},Float64,Float64}} where T&lt;:Number where A&lt;:AbstractSysmatAssembler"><code>FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.geostiffness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geostiffness(self::AbstractFEMMDeforNonlinear, assembler::A, geom::NodalField{FFlt}, un1::NodalField{T}, un::NodalField{T}, tn::FFlt, dtn::FFlt) where {A&lt;:AbstractSysmatAssembler, T&lt;:Number}</code></pre><p>Compute and assemble geometric stiffness matrix.</p><p><strong>Arguments</strong></p><ul><li><code>assembler</code> = matrix assembler,</li><li><code>geom</code> = geometry field: reference coordinates of the nodes,</li><li><code>un1</code> = displacement field at time <code>tn1 = tn + dtn</code>,</li><li><code>un</code> = displacement field at time <code>tn</code>,</li><li><code>tn</code> = time in step <code>n</code></li><li><code>dtn</code> = increment of time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/FEMMDeforNonlinearBaseModule.jl#L325-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.nzebcloads-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.AbstractFEMMDeforNonlinear,A,NodalField{Float64},NodalField{T},NodalField{T},NodalField{T},Float64,Float64}} where T&lt;:Number where A&lt;:SysvecAssembler" href="#FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.nzebcloads-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.AbstractFEMMDeforNonlinear,A,NodalField{Float64},NodalField{T},NodalField{T},NodalField{T},Float64,Float64}} where T&lt;:Number where A&lt;:SysvecAssembler"><code>FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.nzebcloads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nzebcloads(self::AbstractFEMMDeforNonlinear, assembler::A, geom::NodalField{FFlt}, un1::NodalField{T}, un::NodalField{T}, du::NodalField{T}, tn::FFlt, dtn::FFlt) where {A&lt;:SysvecAssembler, T&lt;:Number}</code></pre><p>Compute and assemble load vector due to prescribed increment of displacements.</p><p><strong>Arguments</strong></p><ul><li><code>assembler</code> = matrix assembler,</li><li><code>geom</code> = geometry field: reference coordinates of the nodes,</li><li><code>un1</code> = displacement field at time <code>tn1 = tn + dtn</code>,</li><li><code>un</code> = displacement field at time <code>tn</code>,</li><li><code>du</code> = field of displacement increment prescribed at time <code>tn1 = tn + dtn</code>,   The increment is stored in the fixed values of this field.</li><li><code>tn</code> = time in step <code>n</code></li><li><code>dtn</code> = increment of time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/FEMMDeforNonlinearBaseModule.jl#L200-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.restoringforce-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.AbstractFEMMDeforNonlinear,A,NodalField{Float64},NodalField{T},NodalField{T},Float64,Float64}, Tuple{FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.AbstractFEMMDeforNonlinear,A,NodalField{Float64},NodalField{T},NodalField{T},Float64,Float64,Any}} where T&lt;:Number where A&lt;:AbstractSysvecAssembler" href="#FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.restoringforce-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.AbstractFEMMDeforNonlinear,A,NodalField{Float64},NodalField{T},NodalField{T},Float64,Float64}, Tuple{FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.AbstractFEMMDeforNonlinear,A,NodalField{Float64},NodalField{T},NodalField{T},Float64,Float64,Any}} where T&lt;:Number where A&lt;:AbstractSysvecAssembler"><code>FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.restoringforce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">restoringforce(self::AbstractFEMMDeforNonlinear, assembler::A, geom::NodalField{FFlt}, un1::NodalField{T}, un::NodalField{T}, tn::FFlt, dtn::FFlt, savestate = false) where {A&lt;:AbstractSysvecAssembler, T&lt;:Number}</code></pre><p>Compute the restoring force vector.</p><p>Note: This method <em>UPDATES</em> the state of the FEMM object.  In particular, the material state gets updated.</p><p><strong>Arguments</strong></p><ul><li><code>assembler</code> = vector assembler,</li><li><code>geom</code> = geometry field: reference coordinates of the nodes,</li><li><code>un1</code> = displacement field at time <code>tn1 = tn + dtn</code>,</li><li><code>un</code> = displacement field at time <code>tn</code>,</li><li><code>tn</code> = time in step <code>n</code></li><li><code>dtn</code> = increment of time</li><li><code>savestate</code> = bool flag: should we modify the material states (<code>savestate = true</code>)? Otherwise work with a copy of the material state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/FEMMDeforNonlinearBaseModule.jl#L262-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.AbstractFEMMDeforNonlinear,A,NodalField{Float64},NodalField{T},NodalField{T},Float64,Float64}} where T&lt;:Number where A&lt;:AbstractSysmatAssembler" href="#FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.stiffness-Union{Tuple{T}, Tuple{A}, Tuple{FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.AbstractFEMMDeforNonlinear,A,NodalField{Float64},NodalField{T},NodalField{T},Float64,Float64}} where T&lt;:Number where A&lt;:AbstractSysmatAssembler"><code>FinEtoolsDeforNonlinear.FEMMDeforNonlinearBaseModule.stiffness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stiffness(self::AbstractFEMMDeforNonlinear, assembler::A, geom::NodalField{FFlt}, un1::NodalField{T}, un::NodalField{T}, tn::FFlt, dtn::FFlt) where {A&lt;:AbstractSysmatAssembler, T&lt;:Number}</code></pre><p>Compute and assemble  stiffness matrix.</p><p><strong>Arguments</strong></p><ul><li><code>assembler</code> = matrix assembler,</li><li><code>geom</code> = geometry field: reference coordinates of the nodes,</li><li><code>un1</code> = displacement field at time <code>tn1 = tn + dtn</code>,</li><li><code>un</code> = displacement field at time <code>tn</code>,</li><li><code>tn</code> = time in step <code>n</code></li><li><code>dtn</code> = increment of time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/FEMMDeforNonlinearBaseModule.jl#L145-L157">source</a></section></article><h2 id="Algorithms-1"><a class="docs-heading-anchor" href="#Algorithms-1">Algorithms</a><a class="docs-heading-anchor-permalink" href="#Algorithms-1" title="Permalink"></a></h2><h3 id="Nonlinear-deformation-2"><a class="docs-heading-anchor" href="#Nonlinear-deformation-2">Nonlinear deformation</a><a class="docs-heading-anchor-permalink" href="#Nonlinear-deformation-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.AlgoDeforNonlinearModule.nonlinearstatics-Tuple{Dict{String,Any}}" href="#FinEtoolsDeforNonlinear.AlgoDeforNonlinearModule.nonlinearstatics-Tuple{Dict{String,Any}}"><code>FinEtoolsDeforNonlinear.AlgoDeforNonlinearModule.nonlinearstatics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AlgoDeforNonlinearModule.nonlinearstatics(modeldata::FDataDict)</code></pre><p>Algorithm for static nonlinear deformation (stress) analysis.</p><p>The algorithm chooses steps from the array of load multipliers: the step takes it precisely from the preceding step to the next step in one go.</p><p><strong>Argument</strong></p><p><code>modeldata</code> = dictionary with values for keys</p><ul><li><code>&quot;fens&quot;</code>  = finite element node set</li><li><code>&quot;regions&quot;</code>  = array of region dictionaries</li><li><code>&quot;essential_bcs&quot;</code> = array of essential boundary condition dictionaries</li><li><code>&quot;traction_bcs&quot;</code> = array of traction boundary condition dictionaries</li><li><code>&quot;temperature_change&quot;</code> = dictionary of data for temperature change</li></ul><p>For each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:</p><ul><li><code>&quot;femm&quot;</code> = finite element model machine (mandatory);</li></ul><p>For essential boundary conditions (optional) each dictionary would hold</p><ul><li><code>&quot;displacement&quot;</code> = when this key is not present, the assumption is     that the displacement is fixed at zero (0). Otherwise, this needs to     be set to a function with signature <code>f(x, lambda)</code>, where <code>x</code> is the     location of the node in the reference configuration, and <code>lambda</code> is the     load factor. In other words, whenever this quantity is supplied, it is     implied that the displacement depends on the load factor.</li><li><code>&quot;component&quot;</code> = which component is prescribed  (1, 2, 3)?</li><li><code>&quot;node_list&quot;</code> = list of nodes on the boundary to which the condition     applies (mandatory)</li></ul><p>For traction boundary conditions (optional) each dictionary would hold</p><ul><li><code>&quot;femm&quot;</code> = finite element model machine (mandatory);</li><li><code>&quot;traction_vector&quot;</code> = traction vector, a force-intensity (<code>ForceIntensity</code>) object.</li></ul><p>Control parameters The following attributes  may be supplied:</p><ul><li><code>&quot;load_multipliers&quot;</code> = For what load multipliers should the solution be         calculated? Array of monotonically increasing numbers.</li><li><code>&quot;line_search&quot;</code> = Should we use line search? Boolean.  Default = true.</li><li><code>&quot;maxdu_tol&quot;</code> = Tolerance on the magnitude  of the largest incremental         displacement component.</li><li><code>&quot;maxbal_tol&quot;</code> = Tolerance on the magnitude of the largest out-of-balance         force component.</li><li><code>&quot;iteration_observer&quot;</code> = observer function to be called     after each iteration.  Default is to do nothing.     The observer function has a signature               <code>iteration_observer(lambda,iter,du,modeldata)</code>     where <code>lambda</code> is the current load factor, <code>iter</code> is the iteration     number, <code>du</code> is the nodal field of current displacement increments.</li><li><code>&quot;increment_observer&quot;</code> = observer function     to be called after convergence is reached in each step (optional)     The observer function has a signature               <code>output(lambda, modeldata)</code>     where <code>lambda</code> is the current load factor. Default is to do nothing.     The increment observer can refer to the following key-value pairs in <code>modeldata</code>:     - &quot;un1&quot;: converged displacement in current step     - &quot;un&quot;: converged displacement in the last step     - &quot;t&quot;: current value of load factor     - &quot;dt&quot;: increment of the load factor</li></ul><p><strong>Output</strong></p><p><code>modeldata</code> = the dictionary on input is augmented with the keys</p><ul><li><code>&quot;geom&quot;</code> = the nodal field that is the geometry</li><li><code>&quot;u&quot;</code> = the nodal field that is the computed displacement</li><li><code>&quot;reactions&quot;</code> = computed reaction nodal field</li><li><code>&quot;timing&quot;</code> = dictionary with timing results</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/AlgoDeforNonlinearModule.jl#L25-L96">source</a></section></article><h2 id="Material-models-1"><a class="docs-heading-anchor" href="#Material-models-1">Material models</a><a class="docs-heading-anchor-permalink" href="#Material-models-1" title="Permalink"></a></h2><h3 id="Material-models-for-nonlinear-deformation-1"><a class="docs-heading-anchor" href="#Material-models-for-nonlinear-deformation-1">Material models for nonlinear deformation</a><a class="docs-heading-anchor-permalink" href="#Material-models-for-nonlinear-deformation-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.estimatesoundspeed-Union{Tuple{M}, Tuple{M}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.estimatesoundspeed-Union{Tuple{M}, Tuple{M}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.estimatesoundspeed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">estimatesoundspeed(self::M)  where {M&lt;:AbstractMatDeforNonlinear}</code></pre><p>Estimate sound speed in the undeformed state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/MatDeforNonlinearModule.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.newstate-Union{Tuple{M}, Tuple{M}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.newstate-Union{Tuple{M}, Tuple{M}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.newstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newstate(self::M) where {M&lt;:AbstractMatDeforNonlinear}</code></pre><p>Create an initial material state at an integration point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/MatDeforNonlinearModule.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.tangentmoduli!-Union{Tuple{M}, Tuple{M,Array{Float64,2},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.tangentmoduli!-Union{Tuple{M}, Tuple{M,Array{Float64,2},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.tangentmoduli!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tangentmoduli!(self::M, D::FFltMat, statev::FFltVec, Fn1::FFltMat,
    Fn::FFltMat, tn::FFlt, dtn::FFlt, loc::FFltMat, label::FInt)
    where {M&lt;:AbstractMatDeforNonlinear}</code></pre><p>Calculate the material stiffness matrix.</p><p><strong>Arguments</strong></p><ul><li><code>self</code> = material</li><li><code>D</code> = matrix of tangent moduli, supplied as a buffer and overwritten. Returned as output.</li><li><code>statev</code> = material state vector, the content of this vector must not change   inside this function.</li><li><code>Fn1</code> = deformation gradient at time <code>tn1 = tn + dtn</code>,</li><li><code>Fn</code> = deformation gradient at time <code>tn</code>,</li><li><code>tn</code> = time in step <code>n</code></li><li><code>dtn</code> = increment of time</li><li><code>loc</code> = location of the integration point in the reference coordinates (time <code>t0</code>),</li><li><code>label</code> = label of the element containing the integration point</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>The deformation gradients and the matrix of the tangent moduli are expressed with respect to the local material coordinate system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/MatDeforNonlinearModule.jl#L16-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.totlag2curr!-Tuple{Any,Any,Any}" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.totlag2curr!-Tuple{Any,Any,Any}"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.totlag2curr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">totlag2curr!(c, C, F)</code></pre><p>Convert a total Lagrangean constitutive matrix to a current Lagrangean one (sometimes known as &quot;Eulerian&quot;).</p><ul><li><code>C</code>    = Lagrangean constitutive matrix, 6x6, symmetric</li><li><code>F</code>    = current deformation gradient, F<em>iJ = partial x</em>i / partial X_J</li></ul><p>The transformation is c<em>ijkl = 1/J C</em>IJKL F<em>iI F</em>jJ F<em>kK F</em>lL. In the present case the fourth-order tensor is represented with a 6 x 6 matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/MatDeforNonlinearModule.jl#L102-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.totlag2curr4th!-Tuple{Any,Any,Any}" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.totlag2curr4th!-Tuple{Any,Any,Any}"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.totlag2curr4th!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">totlag2curr4th!(c, C, F)</code></pre><p>Convert a total Lagrangean constitutive matrix to a current Lagrangean one (sometimes known as &quot;Eulerian&quot;).</p><ul><li><code>C</code>    = Lagrangean constitutive matrix, fourth-order tensor</li><li><code>F</code>    = current deformation gradient, F<em>iJ = partial x</em>i / partial X_J</li></ul><p>The transformation is c<em>ijkl = 1/J C</em>IJKL F<em>iI F</em>jJ F<em>kK F</em>lL. Both the input and the output are fourth-order tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/MatDeforNonlinearModule.jl#L187-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.totlag2currsymm!-Tuple{Any,Any,Any}" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.totlag2currsymm!-Tuple{Any,Any,Any}"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.totlag2currsymm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">totlag2currsymm!(c, C, F)</code></pre><p>Convert a total Lagrangean constitutive matrix to a current Lagrangean one (sometimes known as &quot;Eulerian&quot;).</p><ul><li><code>C</code>    = Lagrangean constitutive matrix, 6x6, symmetric</li><li><code>F</code>    = current deformation gradient, F<em>iJ = partial x</em>i / partial X_J</li></ul><p>The transformation is c<em>ijkl = 1/J C</em>IJKL F<em>iI F</em>jJ F<em>kK F</em>lL. In the present case the fourth-order tensor is represented with a 6 x 6 matrix.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>The Lagrangean material stiffness matrices, both input and output, are presumed symmetric.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/MatDeforNonlinearModule.jl#L143-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.update!-Union{Tuple{M}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2}}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64,Any}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.update!-Union{Tuple{M}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2}}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64,Any}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update!(self::M, statev::FFltVec, stress::FFltVec, output::FFltVec,
    Fn1::FFltMat, Fn::FFltMat, tn::FFlt, dtn::FFlt,
    loc::FFltMat=zeros(3,1), label::FInt=0, quantity=:nothing)
    where {M&lt;:AbstractMatDeforNonlinear}</code></pre><p>Update material state.</p><p><strong>Arguments</strong></p><ul><li><code>self</code> = material</li><li><code>statev</code> = state variables: array which is (if necessary) allocated  in an appropriate    size, filled with the state variables, and returned. The contents of this    vector may change as the state of the material is updated by the logic inside    this function. If this change is to be saved, it must happen outside of this    function.</li><li><code>cauchy</code> = Cauchy stress vector, allocated by the caller with a size of the number of stress and strain components, <code>nstressstrain</code>. The components of the stress vector are calculated and stored in the <code>stress</code> vector.</li><li><code>output</code> =  array which is (if necessary) allocated  in an appropriate size,    filled with the output quantity, and returned.</li><li><code>Fn1</code> = deformation gradient at time <code>tn1 = tn + dtn</code>,</li><li><code>Fn</code> = deformation gradient at time <code>tn</code>,</li><li><code>tn</code> = time in step <code>n</code></li><li><code>dtn</code> = increment of time</li><li><code>loc</code> = location of the integration point in the reference coordinates (time <code>t0</code>),</li><li><code>label</code> = label of the element containing the integration point</li></ul><p><strong>Output</strong></p><ul><li><code>cauchy</code> = Cauchy stress vector</li><li><code>output</code> = output array</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>The deformation gradients and the stress vector are expressed with respect to the local material coordinate system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/MatDeforNonlinearModule.jl#L44-L78">source</a></section></article><h3 id="Material-models-for-neohookean-hyperelasticity-1"><a class="docs-heading-anchor" href="#Material-models-for-neohookean-hyperelasticity-1">Material models for neohookean hyperelasticity</a><a class="docs-heading-anchor-permalink" href="#Material-models-for-neohookean-hyperelasticity-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.estimatesoundspeed-Union{Tuple{M}, Tuple{M}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNeohookeanModule.MatDeforNeohookean" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.estimatesoundspeed-Union{Tuple{M}, Tuple{M}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNeohookeanModule.MatDeforNeohookean"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.estimatesoundspeed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">estimatesoundspeed(self::M)  where {M&lt;:AbstractMatDeforNonlinear}</code></pre><p>Estimate sound speed in the undeformed state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/MatDeforNeohookeanModule.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.estimatesoundspeed-Union{Tuple{M}, Tuple{M}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNeohookeanNaiveModule.MatDeforNeohookeanNaive" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.estimatesoundspeed-Union{Tuple{M}, Tuple{M}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNeohookeanNaiveModule.MatDeforNeohookeanNaive"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.estimatesoundspeed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">estimatesoundspeed(self::M)  where {M&lt;:AbstractMatDeforNonlinear}</code></pre><p>Estimate sound speed in the undeformed state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/1665fa23f0026cc8cd4fd6c6c3f1c937a4b99c13/src/MatDeforNeohookeanNaiveModule.jl#L103-L107">source</a></section></article><h3 id="Material-models-for-St-Venant-Kirchhoff-hyperelasticity-1"><a class="docs-heading-anchor" href="#Material-models-for-St-Venant-Kirchhoff-hyperelasticity-1">Material models for St Venant-Kirchhoff hyperelasticity</a><a class="docs-heading-anchor-permalink" href="#Material-models-for-St-Venant-Kirchhoff-hyperelasticity-1" title="Permalink"></a></h3><h3 id="Material-models-for-Mooney-Rivlin-hyperelasticity-1"><a class="docs-heading-anchor" href="#Material-models-for-Mooney-Rivlin-hyperelasticity-1">Material models for Mooney-Rivlin hyperelasticity</a><a class="docs-heading-anchor-permalink" href="#Material-models-for-Mooney-Rivlin-hyperelasticity-1" title="Permalink"></a></h3></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="types.html">« Types</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 11 December 2019 06:08">Wednesday 11 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · FinEtoolsDeforNonlinear.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FinEtoolsDeforNonlinear.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../guide/guide.html">Guide</a></li><li><span class="toctext">Types and Functions</span><ul><li><a class="toctext" href="types.html">Types</a></li><li class="current"><a class="toctext" href="functions.html">Functions</a><ul class="internal"><li><a class="toctext" href="#FEM-machines-1">FEM machines</a></li><li><a class="toctext" href="#Algorithms-1">Algorithms</a></li><li><a class="toctext" href="#Material-models-1">Material models</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Types and Functions</li><li><a href="functions.html">Functions</a></li></ul><a class="edit-page" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/master/docs/src/man/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><h2><a class="nav-anchor" id="FEM-machines-1" href="#FEM-machines-1">FEM machines</a></h2><h3><a class="nav-anchor" id="Nonlinear-deformation-1" href="#Nonlinear-deformation-1">Nonlinear deformation</a></h3><h4><a class="nav-anchor" id="Simple-FE-models-1" href="#Simple-FE-models-1">Simple FE models</a></h4><h2><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h2><h3><a class="nav-anchor" id="Nonlinear-deformation-2" href="#Nonlinear-deformation-2">Nonlinear deformation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsDeforNonlinear.AlgoDeforNonlinearModule.nonlinearstatics-Tuple{Dict{String,Any}}" href="#FinEtoolsDeforNonlinear.AlgoDeforNonlinearModule.nonlinearstatics-Tuple{Dict{String,Any}}"><code>FinEtoolsDeforNonlinear.AlgoDeforNonlinearModule.nonlinearstatics</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">AlgoDeforNonlinearModule.nonlinearstatics(modeldata::FDataDict)</code></pre><p>Algorithm for static nonlinear deformation (stress) analysis.</p><p>The algorithm chooses steps from the array of load multipliers: the step takes it precisely from the preceding step to the next step in one go.</p><p><strong>Argument</strong></p><p><code>modeldata</code> = dictionary with values for keys</p><ul><li><code>&quot;fens&quot;</code>  = finite element node set</li><li><code>&quot;regions&quot;</code>  = array of region dictionaries</li><li><code>&quot;essential_bcs&quot;</code> = array of essential boundary condition dictionaries</li><li><code>&quot;traction_bcs&quot;</code> = array of traction boundary condition dictionaries</li><li><code>&quot;temperature_change&quot;</code> = dictionary of data for temperature change</li></ul><p>For each region (connected piece of the domain made of a particular material), mandatory, the  region dictionary  contains values for keys:</p><ul><li><code>&quot;femm&quot;</code> = finite element model machine (mandatory);</li></ul><p>For essential boundary conditions (optional) each dictionary would hold</p><ul><li><code>&quot;displacement&quot;</code> = when this key is not present, the assumption is     that the displacement is fixed at zero (0). Otherwise, this needs to     be set to a function with signature <code>f(x, lambda)</code>, where <code>x</code> is the     location of the node in the reference configuration, and <code>lambda</code> is the     load factor. In other words, whenever this quantity is supplied, it is     implied that the displacement depends on the load factor.</li><li><code>&quot;component&quot;</code> = which component is prescribed  (1, 2, 3)?</li><li><code>&quot;node_list&quot;</code> = list of nodes on the boundary to which the condition     applies (mandatory)</li></ul><p>For traction boundary conditions (optional) each dictionary would hold</p><ul><li><code>&quot;femm&quot;</code> = finite element model machine (mandatory);</li><li><code>&quot;traction_vector&quot;</code> = traction vector, a force-intensity (<code>ForceIntensity</code>) object.</li></ul><p>Control parameters The following attributes  may be supplied:</p><ul><li><code>&quot;load_multipliers&quot;</code> = For what load multipliers should the solution be         calculated? Array of monotonically increasing numbers.</li><li><code>&quot;line_search&quot;</code> = Should we use line search? Boolean.  Default = true.</li><li><code>&quot;maxdu_tol&quot;</code> = Tolerance on the magnitude  of the largest incremental         displacement component.</li><li><code>&quot;maxbal_tol&quot;</code> = Tolerance on the magnitude of the largest out-of-balance         force component.</li><li><code>&quot;iteration_observer&quot;</code> = observer function to be called     after each iteration.  Default is to do nothing.     The observer function has a signature               <code>iteration_observer(lambda,iter,du,modeldata)</code>     where <code>lambda</code> is the current load factor, <code>iter</code> is the iteration     number, <code>du</code> is the nodal field of current displacement increments.</li><li><code>&quot;increment_observer&quot;</code> = observer function     to be called after convergence is reached in each step (optional)     The observer function has a signature               <code>output(lambda, modeldata)</code>     where <code>lambda</code> is the current load factor. Default is to do nothing.     The increment observer can refer to the following key-value pairs in <code>modeldata</code>:     - &quot;un1&quot;: converged displacement in current step     - &quot;un&quot;: converged displacement in the last step     - &quot;t&quot;: current value of load factor     - &quot;dt&quot;: increment of the load factor</li></ul><p><strong>Output</strong></p><p><code>modeldata</code> = the dictionary on input is augmented with the keys</p><ul><li><code>&quot;geom&quot;</code> = the nodal field that is the geometry</li><li><code>&quot;u&quot;</code> = the nodal field that is the computed displacement</li><li><code>&quot;reactions&quot;</code> = computed reaction nodal field</li><li><code>&quot;timing&quot;</code> = dictionary with timing results</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/5015b92131f78253119663f04a95870ea35ff47a/src/AlgoDeforNonlinearModule.jl#L25-L96">source</a></section><h2><a class="nav-anchor" id="Material-models-1" href="#Material-models-1">Material models</a></h2><h3><a class="nav-anchor" id="Material-models-for-nonlinear-deformation-1" href="#Material-models-for-nonlinear-deformation-1">Material models for nonlinear deformation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.newstate-Union{Tuple{M}, Tuple{M}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.newstate-Union{Tuple{M}, Tuple{M}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.newstate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">newstate(self::M) where {M&lt;:AbstractMatDeforNonlinear}</code></pre><p>Create an initial material state at an integration point.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/5015b92131f78253119663f04a95870ea35ff47a/src/MatDeforNonlinearModule.jl#L82-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.tangentmoduli!-Union{Tuple{M}, Tuple{M,Array{Float64,2},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.tangentmoduli!-Union{Tuple{M}, Tuple{M,Array{Float64,2},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.tangentmoduli!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tangentmoduli!(self::M, D::FFltMat, statev::FFltVec, Fn1::FFltMat,
    Fn::FFltMat, tn::FFlt, dtn::FFlt, loc::FFltMat, label::FInt)
    where {M&lt;:AbstractMatDeforNonlinear}</code></pre><p>Calculate the material stiffness matrix.</p><p><strong>Arguments</strong></p><ul><li><code>self</code> = material</li><li><code>D</code> = matrix of tangent moduli, supplied as a buffer and overwritten. Returned</li></ul><p>as output.</p><ul><li><code>statev</code> = material state vector, the content of this vector must not change   inside this function.</li><li><code>Fn1</code> = deformation gradient at time <code>tn1 = tn + dtn</code>,</li><li><code>Fn</code> = deformation gradient at time <code>tn</code>,</li><li><code>tn</code> = time in step <code>n</code></li><li><code>dtn</code> = increment of time</li><li><code>loc</code> = location of the integration point in the reference coordinates (time <code>t0</code>),</li><li><code>label</code> = label of the element containing the integration point</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><p>The deformation gradients and the matrix of the tangent moduli are expressed with respect to the local material coordinate system.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/5015b92131f78253119663f04a95870ea35ff47a/src/MatDeforNonlinearModule.jl#L15-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtoolsDeforNonlinear.MatDeforNonlinearModule.update!-Union{Tuple{M}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2}}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64,Any}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear" href="#FinEtoolsDeforNonlinear.MatDeforNonlinearModule.update!-Union{Tuple{M}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2}}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64}, Tuple{M,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Float64,Array{Float64,2},Int64,Any}} where M&lt;:FinEtoolsDeforNonlinear.MatDeforNonlinearModule.AbstractMatDeforNonlinear"><code>FinEtoolsDeforNonlinear.MatDeforNonlinearModule.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">update!(self::M, statev::FFltVec, stress::FFltVec, output::FFltVec,
    Fn1::FFltMat, Fn::FFltMat, tn::FFlt, dtn::FFlt,
    loc::FFltMat=zeros(3,1), label::FInt=0, quantity=:nothing)
    where {M&lt;:AbstractMatDeforNonlinear}</code></pre><p>Update material state.</p><p><strong>Arguments</strong></p><ul><li><code>self</code> = material</li><li><code>statev</code> = state variables: array which is (if necessary) allocated  in an appropriate    size, filled with the state variables, and returned. The contents of this    vector may change as the state of the material is updated by the logic inside    this function. If this change is to be saved, it must happen outside of this    function.</li><li><code>stress</code> = stress vector, allocated by the caller with a size of the number of    stress and strain components, <code>nstressstrain</code>. The components of the stress    vector are calculated and stored in the <code>stress</code> vector.</li><li><code>output</code> =  array which is (if necessary) allocated  in an appropriate size,    filled with the output quantity, and returned.</li><li><code>Fn1</code> = deformation gradient at time <code>tn1 = tn + dtn</code>,</li><li><code>Fn</code> = deformation gradient at time <code>tn</code>,</li><li><code>tn</code> = time in step <code>n</code></li><li><code>dtn</code> = increment of time</li><li><code>loc</code> = location of the integration point in the reference coordinates (time <code>t0</code>),</li><li><code>label</code> = label of the element containing the integration point</li></ul><p><strong>Output</strong></p><ul><li><code>stress</code> = stress vector</li><li><code>output</code> = output array</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><p>The deformation gradients and the stress vector are expressed with respect to the local material coordinate system.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtoolsDeforNonlinear.jl/blob/5015b92131f78253119663f04a95870ea35ff47a/src/MatDeforNonlinearModule.jl#L43-L77">source</a></section><h3><a class="nav-anchor" id="Material-models-for-neohookean-hyperelasticity-1" href="#Material-models-for-neohookean-hyperelasticity-1">Material models for neohookean hyperelasticity</a></h3><footer><hr/><a class="previous" href="types.html"><span class="direction">Previous</span><span class="title">Types</span></a></footer></article></body></html>
